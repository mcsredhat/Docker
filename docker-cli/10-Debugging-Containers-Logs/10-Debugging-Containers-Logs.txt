# Docker Container Debugging & Logging
## Introduction
Debugging is an essential skill for working with Docker containers. When running applications in isolated environments, traditional debugging methods often don't apply, making Docker-specific tools and techniques crucial. This comprehensive guide explores methods for troubleshooting container issues, analyzing logs, investigating build failures, and gathering detailed information about container state and configuration.
## 1. Understanding Container Logs
### The Importance of Container Logging
Container logs capture the stdout and stderr output streams from the main process running inside a container. These logs provide critical insights into:
- Application startup messages and errors
- Runtime behavior and warnings
- Performance issues
- Security alerts
- Application-specific information
Since containers are designed to be ephemeral, logs often serve as the primary diagnostic tool when problems occur.

### Using the `docker logs` Command
The `docker logs` command is your first line of defense when troubleshooting container issues.
**Basic Syntax:**
docker logs <container-id-or-name> [options]

**Key Options:**

| Option | Description | Example |
|--------|-------------|---------|
| `--follow` or `-f` | Stream logs in real-time | `docker logs -f my-container` |
| `--tail <n>` | Show only the last n lines | `docker logs --tail 100 my-container` |
| `--since <time>` | Show logs since specified time | `docker logs --since 30m my-container` |
| `--until <time>` | Show logs before specified time | `docker logs --until "2023-05-01T10:00:00" my-container` |
| `--timestamps` or `-t` | Add timestamps | `docker logs -t my-container` |

### Practical Examples
#### Basic Log Retrieval
# Start a container
docker run -d --name web-server nginx:latest
# View all logs
docker logs web-server
This displays all logs from the container's stdout and stderr, showing Nginx startup messages and access logs.
#### Real-Time Log Monitoring
# Stream logs in real-time
docker logs -f web-server

# In another terminal, generate traffic
curl http://localhost:80

# Watch as new logs appear (press Ctrl+C to exit)
This is particularly useful during development or when troubleshooting intermittent issues.

#### Viewing Recent Log Entries
# Show only the last 10 lines
docker logs --tail 10 web-server
# Show logs from the last 5 minutes
docker logs --since 5m web-server
These commands help when you need to focus on recent events without filtering through extensive output.

### Log Persistence
By default, Docker logs are stored using the json-file logging driver, which keeps logs on the host filesystem. However, container logs are lost when a container is removed unless you:
1. Configure log rotation to prevent excessive disk usage:
   docker run --log-opt max-size=10m --log-opt max-file=3 nginx
2. Use a logging driver that sends logs to external systems:
   docker run --log-driver=syslog nginx
3. Mount a volume to persist logs:
   docker run -v /path/on/host:/var/log/nginx nginx

## 2. Troubleshooting Failed Container Builds
### Common Build Failure Causes
Docker build failures typically fall into several categories:
1. **Syntax errors** in the Dockerfile
2. **Network issues** during package installation
3. **Missing dependencies** or incompatible versions
4. **Permission problems** when accessing files or directories
5. **Resource limitations** (disk space, memory)
6. **Cached layers** hiding changes or masking issues
### Using `--no-cache` to Debug Builds
When builds fail unexpectedly or when you need to ensure a completely fresh build, the `--no-cache` option is invaluable.
docker build --no-cache -t my-image:latest .
This forces Docker to execute each instruction without using any cached layers, which can reveal issues that might be hidden by outdated cache.

### Examining Intermediate Containers
When a build fails, Docker preserves the last successful intermediate container, which you can examine to debug the issue.
# From the build output, note the last successfully built layer ID
# Example output: Step 3/7 : RUN apt-get update
#  ---> Running in a72f40c16532
#  ---> 6b1abe3a6d6c
# Use the layer ID to start an interactive shell
docker run -it 6b1abe3a6d6c /bin/bash
# Now you can explore the container state and try commands manually
This technique allows you to interactively investigate the container state just before the failure occurred.

### Practical Build Debugging Example
Consider this problematic Dockerfile:
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y python3
RUN nonexistent-command  # Intentional error
CMD ["python3", "--version"]

Let's debug this step by step:
1. **Attempt the build:**
   docker build -t debug-example .
   This will fail at the `nonexistent-command` step.

2. **Examine the error message:**
   Step 3/4 : RUN nonexistent-command
    ---> Running in 7a2e8f3b6e1c
   /bin/sh: 1: nonexistent-command: not found
   The command '/bin/sh: 1: nonexistent-command: not found' returned a non-zero code: 127
   The error code 127 indicates "command not found."

3. **Launch an interactive shell using the last successful layer:**
   # The ID will be different in your case
   docker run -it abc123def456 /bin/bash

4. **Try the command manually:**
   nonexistent-command
   # Output: bash: nonexistent-command: command not found
5. **Fix the Dockerfile by replacing the problematic command:**
   FROM ubuntu:20.04
   RUN apt-get update && apt-get install -y python3
   RUN echo "Command executed successfully"
   CMD ["python3", "--version"]
6. **Rebuild without cache:**
   docker build --no-cache -t debug-example .

### Advanced Build Debugging Techniques
1. **Use multi-stage builds to isolate issues:**
   FROM ubuntu:20.04 as build-stage
   RUN apt-get update && apt-get install -y python3
   FROM build-stage as test-stage
   RUN python3 --version
   FROM build-stage
   CMD ["python3", "--version"]

2. **Add debugging statements:**
   ```dockerfile
   RUN echo "DEBUG: About to install packages" && \
       apt-get update && \
       echo "DEBUG: Update completed" && \
       apt-get install -y python3 && \
       echo "DEBUG: Installation completed"

3. **Use verbose flags on commands:**
   ```dockerfile
   RUN apt-get update && apt-get install -y --verbose-versions python3
## 3. Inspecting Container Details
### The Power of `docker inspect`
The `docker inspect` command provides detailed metadata about containers, helping diagnose runtime issues, configuration problems, and network connectivity issues.
**Basic Syntax:**
docker inspect <container-id-or-name> [options]
**Key Options:**
- `--format` or `-f`: Extract specific fields using Go templates
- `--type`: Specify the type of object to inspect (container, image, volume, etc.)

### Critical Information Revealed by Inspect
When examining a container with `docker inspect`, pay attention to these important sections:
1. **State**: Container status, exit code, start time, and error messages
2. **Config**: Command, environment variables, working directory, and volumes
3. **NetworkSettings**: IP address, port mappings, and network configuration
4. **Mounts**: Volume and bind mount details
5. **HostConfig**: Resource limits, restart policy, and runtime configuration

### Using Format Templates for Targeted Information
The `--format` option allows you to extract specific information:
# Get exit code and error message
docker inspect --format '{{.State.ExitCode}} {{.State.Error}}' my-container
# Get IP address
docker inspect --format '{{.NetworkSettings.IPAddress}}' my-container
# Get all environment variables
docker inspect --format '{{range .Config.Env}}{{.}}{{println}}{{end}}' my-container
# Get mounted volumes
docker inspect --format '{{range .Mounts}}{{.Source}} -> {{.Destination}}{{println}}{{end}}' my-container

### Understanding Exit Codes
Exit codes provide valuable clues about why a container stopped:

| Exit Code | Meaning | Common Cause |
|-----------|---------|--------------|
| 0 | Success | Normal termination |
| 1 | General error | Application error or exception |
| 125 | Docker daemon error | Issues with the Docker runtime |
| 126 | Command cannot be invoked | Permission problem |
| 127 | Command not found | Missing executable or typo |
| 137 | SIGKILL received | Out of memory or forced kill |
| 143 | SIGTERM received | Graceful termination request |

### Practical Inspection Example
Let's examine a container that crashed on startup:
# Run a container with a command that doesn't exist
docker run -d --name crash-demo alpine nonexistent-command
# Check container status
docker ps -a | grep crash-demo
# Output shows "Exited (127)" status
# View detailed information
docker inspect crash-demo
# Extract just the state information
docker inspect --format '{{json .State}}' crash-demo | jq
This reveals the exact cause of failure through the exit code and provides detailed information about when the container ran and how it was configured.

## 4. Comprehensive Debugging Workflow
A systematic approach to container debugging combines multiple techniques:
### Step 1: Identify the Problem
# List all containers, including stopped ones
docker ps -a
# Look for containers with non-zero exit codes
docker ps -a --filter "exited=1"

### Step 2: Examine Logs
# Check container logs
docker logs problem-container
# Look at the last few log entries
docker logs --tail 20 problem-container

### Step 3: Inspect Container Details
# Get exit code and error message
docker inspect --format '{{.State.ExitCode}} {{.State.Error}}' problem-container
# Check full configuration
docker inspect problem-container

### Step 4: Reproduce in Interactive Mode
# Run the same image with an interactive shell instead of the default command
docker run -it --entrypoint /bin/sh problem-image:tag

# Try to run the original command manually
command-that-failed
### Step 5: Test with Minimal Configuration
# Run with minimal options to isolate issues
docker run --rm problem-image:tag

## 5. Hands-On Debugging Exercise: Web Server Troubleshooting
Let's work through a complete debugging scenario for a web server that isn't responding as expected.
### Scenario Setup
1. **Create a simple web server with an intentional issue:**
```dockerfile
FROM nginx:latest
COPY nonexistent-file.html /usr/share/nginx/html/index.html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

2. **Build and run the container:**
docker build -t buggy-web:latest .
docker run -d --name buggy-server -p 8080:80 buggy-web:latest

### Debugging Process
1. **Check container status:**
docker ps -a | grep buggy-server
If the container is running, the issue might be inside the application. If it exited, we need to investigate why.
2. **Examine logs:**
docker logs buggy-server
Look for error messages like:
2023/05/01 12:34:56 [error] 6#6: open() "/usr/share/nginx/html/index.html" failed (2: No such file or directory)
3. **Inspect the container:**
docker inspect buggy-server
Check the configuration, particularly mounts and volumes.
4. **Test interactively:**
docker exec -it buggy-server /bin/bash
ls -la /usr/share/nginx/html/
This confirms that `index.html` is missing.
5. **Fix the issue:**
Create a new Dockerfile:
FROM nginx:latest
RUN echo "<html><body><h1>Hello, Docker!</h1></body></html>" > /usr/share/nginx/html/index.html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

Rebuild and run:
docker build -t fixed-web:latest .
docker run -d --name fixed-server -p 8080:80 fixed-web:latest
curl http://localhost:8080

## 6. Advanced Debugging Techniques
### Using Health Checks for Proactive Monitoring
Configure health checks to detect problems early:
```dockerfile
FROM nginx:latest
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

### Enabling Docker Daemon Debug Mode
For troubleshooting issues with the Docker daemon itself:
# Edit daemon configuration
sudo nano /etc/docker/daemon.json
# Add debug configuration
{
  "debug": true
}

# Restart Docker
sudo systemctl restart docker
Logs will be available in the system journal or Docker log files.

### Using Docker Events for Troubleshooting
Monitor Docker events to understand container lifecycle:
# Watch real-time events
docker events
# Filter events for a specific container
docker events --filter container=my-container
### Analyzing Resource Usage
Monitor resource consumption to identify potential bottlenecks:
# Check resource usage
docker stats
# Monitor specific container
docker stats my-container

