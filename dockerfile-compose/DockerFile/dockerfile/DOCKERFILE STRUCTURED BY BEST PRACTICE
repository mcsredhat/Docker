# ==============================================================================
# DOCKERFILE STRUCTURED BY BEST PRACTICES
# Optimally ordered for layer caching and maintainability
# Python Flask Application with Advanced Docker Features
# ==============================================================================

# ==============================================================================
# 1. FROM - Base Image Selection
# ==============================================================================
# Use specific version tags for reproducibility
# Equivalent Docker CLI: docker pull python:3.11-slim
FROM python:3.11-slim

# ==============================================================================
# 2. LABEL - Image Metadata (OCI Standard)
# ==============================================================================
# Add metadata early as it rarely changes
# Equivalent Docker CLI: docker build --label "key=value" .
# View with: docker inspect <image> | jq '.[0].Config.Labels'
LABEL maintainer="dev@example.com" \
      version="2.0.0" \
      description="Production-ready Flask application with advanced Docker features" \
      org.opencontainers.image.title="Flask Advanced App" \
      org.opencontainers.image.description="Enhanced Flask application demonstrating Docker best practices" \
      org.opencontainers.image.version="2.0.0" \
      org.opencontainers.image.authors="dev@example.com" \
      org.opencontainers.image.source="https://github.com/example/flask-advanced" \
      org.opencontainers.image.documentation="https://docs.example.com/flask-app" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.vendor="Example Corp"

# ==============================================================================
# 3. ARG - Build-time Variables
# ==============================================================================
# Define build arguments before ENV to use in environment variables
# Equivalent Docker CLI: docker build --build-arg APP_ENV=production .
ARG APP_ENV=production
ARG PYTHON_VERSION=3.11
ARG USER_ID=1000
ARG GROUP_ID=1000
ARG APP_PORT=5000
ARG HEALTH_CHECK_URL=http://localhost:5000/health

# ==============================================================================
# 4. ENV - Runtime Environment Variables
# ==============================================================================
# Set environment variables using ARG values and Python-specific settings
# Equivalent Docker CLI: docker run -e APP_ENV=production <image>
ENV APP_ENV=${APP_ENV} \
    PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1 \
    FLASK_APP=src/app.py \
    FLASK_ENV=${APP_ENV} \
    FLASK_RUN_HOST=0.0.0.0 \
    FLASK_RUN_PORT=${APP_PORT} \
    PATH="/home/appuser/.local/bin:${PATH}" \
    DEBIAN_FRONTEND=noninteractive

# ==============================================================================
# 5. RUN - System Setup and Dependencies
# ==============================================================================
# Install system dependencies and create user (grouped for optimal caching)
# Equivalent Docker CLI: docker run --rm -it python:3.11-slim bash -c "apt-get update..."

# System packages installation
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    wget \
    git \
    build-essential \
    gcc \
    g++ \
    make \
    libpq-dev \
    libssl-dev \
    libffi-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /tmp/* \
    && pip install --upgrade pip setuptools wheel

# User and group creation with specific IDs
# Equivalent Docker CLI: docker run bash -c "groupadd -g 1000 appgroup && useradd -u 1000..."
RUN groupadd -g ${GROUP_ID} appgroup \
    && useradd -u ${USER_ID} -g appgroup -M -s /bin/bash appuser \
    && mkdir -p /home/appuser \
    && chown -R appuser:appgroup /home/appuser

# ==============================================================================
# 6. WORKDIR - Set Working Directory
# ==============================================================================
# Set working directory and ensure proper ownership
# Equivalent Docker CLI: docker run -w /app <image>
WORKDIR /app

# Create application directories with proper ownership
RUN mkdir -p /app/{src,static,templates,logs,uploads,instance,tests} \
    && chown -R appuser:appgroup /app

# ==============================================================================
# 7. COPY/ADD - File Operations (Dependency Files First)
# ==============================================================================
# Copy dependency files first for optimal Docker layer caching
# Equivalent Docker CLI: docker cp requirements.txt <container>:/app/

# Copy Python dependency files
COPY --chown=appuser:appgroup requirements*.txt ./
COPY --chown=appuser:appgroup pyproject.toml setup.py ./

# Install Python dependencies as root for system-wide installation
# Equivalent Docker CLI: docker exec <container> pip install -r requirements.txt
RUN pip install --no-cache-dir -r requirements.txt \
    && if [ "${APP_ENV}" = "development" ] && [ -f requirements-dev.txt ]; then \
         pip install --no-cache-dir -r requirements-dev.txt; \
       fi \
    && if [ -f pyproject.toml ]; then \
         pip install --no-cache-dir -e .; \
       fi

# ADD example - Fetch remote configuration or extract archives
# Equivalent Docker CLI: wget <url> && docker cp <file> <container>:/tmp/
ADD --chown=appuser:appgroup https://raw.githubusercontent.com/docker-library/hello-world/master/hello.sh /tmp/hello.sh

# Copy application source code (changes frequently, so comes last)
# Equivalent Docker CLI: docker cp src/ <container>:/app/src/
COPY --chown=appuser:appgroup src/ ./src/
COPY --chown=appuser:appgroup static/ ./static/
COPY --chown=appuser:appgroup templates/ ./templates/
COPY --chown=appuser:appgroup tests/ ./tests/
COPY --chown=appuser:appgroup *.py ./
COPY --chown=appuser:appgroup *.cfg *.ini *.json ./

# Set permissions for scripts and create necessary files
RUN chmod +x /tmp/hello.sh \
    && touch /app/logs/app.log \
    && chown -R appuser:appgroup /app

# ==============================================================================
# 8. USER - Security Context
# ==============================================================================
# Switch to non-root user for security (always after file operations)
# Equivalent Docker CLI: docker exec -u appuser <container> <command>
USER appuser

# ==============================================================================
# 9. VOLUME - Persistent Data
# ==============================================================================
# Define volume mount points for persistent data
# Equivalent Docker CLI: docker run -v /app/logs:/host/logs <image>
VOLUME ["/app/logs", "/app/uploads", "/app/instance"]

# ==============================================================================
# 10. EXPOSE - Port Documentation
# ==============================================================================
# Document exposed ports (doesn't actually publish them)
# Equivalent Docker CLI: docker run -p 5000:5000 -p 8080:8080 <image>
EXPOSE ${APP_PORT} 8080 9090

# ==============================================================================
# 11. HEALTHCHECK - Container Health Monitoring
# ==============================================================================
# Define health check for container orchestration
# Equivalent Docker CLI: docker exec <container> curl -f http://localhost:5000/health
HEALTHCHECK --interval=30s --timeout=10s --start-period=45s --retries=3 \
    CMD curl -f ${HEALTH_CHECK_URL} || exit 1

# ==============================================================================
# 12. STOPSIGNAL - Graceful Shutdown
# ==============================================================================
# Specify signal for graceful container shutdown
# Equivalent Docker CLI: docker stop --signal=SIGTERM <container>
STOPSIGNAL SIGTERM

# ==============================================================================
# 13. SHELL - Override Default Shell
# ==============================================================================
# Set shell for RUN commands (useful for advanced scripting)
SHELL ["/bin/bash", "-o", "pipefail", "-c"]

# ==============================================================================
# 14. ONBUILD - Trigger Instructions
# ==============================================================================
# Instructions that run when this image is used as a base
# Equivalent Docker CLI: Automatically executed when FROM <this-image>
ONBUILD COPY requirements.txt .
ONBUILD RUN pip install --no-cache-dir -r requirements.txt
ONBUILD COPY . .

# ==============================================================================
# 15. ENTRYPOINT + CMD - Container Execution (Advanced Pattern)
# ==============================================================================
# Use ENTRYPOINT + CMD pattern for maximum flexibility
# ENTRYPOINT: Fixed part of the command (harder to override)
# CMD: Default arguments (easily overrideable)

# Option A: Flask development server (commented out)
# ENTRYPOINT ["python", "-m", "flask"]
# CMD ["run", "--host=0.0.0.0", "--port=5000"]

# Option B: Production WSGI server (Gunicorn)
# Equivalent Docker CLI: docker run <image> # uses default CMD
# Override: docker run <image> --workers 2 --bind 0.0.0.0:8000
ENTRYPOINT ["gunicorn"]
CMD ["--bind", "0.0.0.0:5000", "--workers", "2", "--worker-class", "sync", "--worker-connections", "1000", "--max-requests", "1000", "--max-requests-jitter", "100", "--timeout", "30", "--keepalive", "5", "--access-logfile", "-", "--error-logfile", "-", "src.app:app"]

# Option C: Custom entrypoint script (most flexible)
# COPY --chown=appuser:appgroup entrypoint.sh /entrypoint.sh
# RUN chmod +x /entrypoint.sh
# ENTRYPOINT ["/entrypoint.sh"]
# CMD ["gunicorn", "src.app:app"]

