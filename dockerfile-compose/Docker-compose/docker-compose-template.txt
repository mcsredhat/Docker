version: '3.8'

services:
  app:
    image: myapp/image:latest
    container_name: myapp_container
    hostname: myapp-host
    
    # Labels help organize and identify containers - think of them as tags
    # These are metadata that don't affect functionality but help with management
    labels:
      - "app=myapp"
      - "environment=production"
    
    # Working directory inside the container - where commands will run from
    working_dir: /usr/src/app
    
    # The command that starts your application when container launches
    entrypoint: ./start.sh
    
    # Environment variables - configuration values your app can read
    # These act like settings that your application uses at runtime
    environment:
      - BACKEND_HOST=backend.internal
      - TZ=UTC
    
    # Resource limits - prevents container from consuming too much system resources
    # This is crucial for production to maintain system stability
    deploy:
      resources:
        limits:
          memory: 512M        # Maximum RAM the container can use
          cpus: '0.50'        # Maximum CPU cores (0.5 = half a core)
        reservations:
          memory: 256M        # Added: minimum guaranteed memory
          cpus: '0.25'        # Added: minimum guaranteed CPU
        restart_policy:       # Added: how to handle container failures
          condition: on-failure
          delay: 5s
          max_attempts: 3
    
    # System limits - controls low-level system resources
    # These prevent resource exhaustion at the OS level
    ulimits:
      nofile:               # Number of open files allowed
        soft: 65536
        hard: 65536
      nproc:                # Number of processes allowed
        soft: 4096
        hard: 4096
    
    # Network configuration - how container communicates
    # Networks isolate containers and control traffic flow
    networks:
      app_net:
        aliases:
          - myapp           # Alternative name other containers can use
        ipv4_address: 172.20.0.10  # Fixed IP within the network
    
    # DNS servers - where container resolves domain names
    # Using public DNS ensures reliable name resolution
    dns:
      - 8.8.8.8            # Google DNS
      - 1.1.1.1            # Cloudflare DNS
    
    # Port mapping - exposes container ports to host system
    # Format: "host_port:container_port"
    ports:
      - "8080:80"           # Host port 8080 maps to container port 80
    
    # Volume mounts - persistent storage and file sharing
    # These survive container restarts and share data with host
    volumes:
      - app_data:/data:rw              # Named volume for application data
      - app_logs:/logs:rw              # Named volume for log files
      - app_config:/etc/app:ro         # Config volume (read-only for security)
      - /tmp/myapp:/tmp                # Host directory mount for temp files
    
    # Temporary filesystems - fast, memory-based storage
    # These are cleared when container stops - good for temp files
    tmpfs:
      - /tmp:rw,size=50m               # 50MB temp space
      - /var/tmp:rw,size=50m           # Additional temp space
      - /run:rw,size=10m               # Runtime files
    
    # Security settings - follows principle of least privilege
    user: "1000:1000"                  # Run as non-root user for security
    read_only: true                    # Makes root filesystem read-only
    
    # Remove all capabilities and add back only what's needed
    cap_drop:
      - ALL                            # Drop all Linux capabilities
    # cap_add:                         # Add specific capabilities if needed
    #   - NET_BIND_SERVICE             # Example: bind to ports < 1024
    
    # Additional security options
    security_opt:
      - no-new-privileges:true         # Prevents privilege escalation
    
    # Restart policy - how Docker handles container failures
    restart: unless-stopped            # Always restart except when manually stopped
    
    # Health monitoring - Docker checks if container is working properly
    # This enables automatic recovery and load balancer integration
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s                    # Check every 30 seconds
      timeout: 5s                      # Wait 5 seconds for response
      retries: 3                       # Try 3 times before marking unhealthy
      start_period: 30s                # Wait 30s after start before checking
    
    # Logging configuration - controls how container logs are handled
    # Prevents logs from filling up disk space
    logging:
      driver: json-file                # Standard Docker logging format
      options:
        max-size: "10m"                # Maximum size per log file
        max-file: "3"                  # Keep 3 log files (rotation)
        compress: "true"               # Compress old log files
    
    # Dependencies - ensures other services start first
    depends_on:
      - db                             # Wait for database to be ready
    
    # Added secrets and configs usage
    secrets:
      - app_secret_key                 # Mount secret file
      - api_token
    configs:
      - source: app_config             # Mount config file
        target: /etc/app/app.conf
      - source: nginx_config
        target: /etc/nginx/nginx.conf

  # Example database service to demonstrate dependencies
  db:
    image: postgres:13
    container_name: myapp_db
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: myapp_user
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    volumes:
      - db_data:/var/lib/postgresql/data
    networks:
      - app_net
    secrets:
      - db_password
    restart: unless-stopped

# Volume definitions - persistent storage that survives container removal
# Think of these as external hard drives that containers can mount
volumes:
  # Application data volume - stores your app's important files
  app_data:
    driver: local                      # Stored on local machine
    driver_opts:
      type: none                       # Direct bind mount
      o: bind                          # Bind mount option
      device: /opt/myapp/data          # Host directory path
  
  # Log storage volume - keeps application logs safe
  app_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /var/log/myapp
  
  # Configuration volume - stores app configuration files
  app_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /etc/myapp
  
  # Database volume - persists database files
  db_data:
    driver: local                      # Uses Docker's default volume storage

# Network definitions - virtual networks for container communication
# Networks provide isolation and controlled communication between containers
networks:
  app_net:
    driver: bridge                     # Standard Docker network type
    
    # IP address management - defines network addressing
    ipam:
      driver: default                  # Use Docker's default IPAM
      config:
        - subnet: 172.20.0.0/16        # Network range (65,534 possible IPs)
          gateway: 172.20.0.1          # Router IP for the network
          ip_range: 172.20.1.0/24      # Added: limit auto-assigned IPs
    
    # Driver-specific options - fine-tune network behavior
    driver_opts:
      com.docker.network.bridge.name: br-app     # Custom bridge name
      com.docker.network.driver.mtu: 1500        # Maximum transmission unit
      com.docker.network.bridge.enable_icc: "true"  # Inter-container communication

# Secrets management - secure way to handle sensitive data
# Secrets are encrypted and only accessible to authorized containers
secrets:
  app_secret_key:
    file: ./secrets/app_key.txt        # Read from local file
    # external: true                   # Alternative: use external secret
    # name: prod_secret_key           # Reference to external secret name
  
  api_token:
    file: ./secrets/api_token.txt
  
  # Added database password secret
  db_password:
    file: ./secrets/db_password.txt

# Configuration files - non-sensitive configuration data
# Configs are similar to secrets but for non-sensitive information
configs:
  app_config:
    file: ./config/app.conf            # Application configuration
    # external: true                   # Alternative: use external config
    # name: prod_app_config           # Reference to external config name
  
  nginx_config:
    file: ./config/nginx.conf          # Web server configuration
